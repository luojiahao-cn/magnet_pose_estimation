# 磁铁位姿估计置信度设计方案

本文档介绍多种置信度设计方案，可根据应用需求选择或组合使用。

## 当前实现方案

**方案1：基于残差和传感器数量的综合置信度**
- 优点：简单直观，计算快速
- 缺点：未考虑空间分布、时间一致性等因素
- 适用场景：实时性要求高的场景

---

## 方案2：多维度置信度

### 设计思路
将置信度分解为位置置信度和姿态置信度，分别评估。

### 消息定义
```cpp
// MagnetPose.msg 扩展
float64 confidence           # 综合置信度
float64 position_confidence  # 位置置信度 [0.0, 1.0]
float64 orientation_confidence  # 姿态置信度 [0.0, 1.0]
```

### 计算逻辑
```cpp
// 位置置信度：基于位置残差和传感器空间分布
double position_confidence = computePositionConfidence(
    position_residual, 
    sensor_spatial_distribution
);

// 姿态置信度：基于方向残差和磁场方向性
double orientation_confidence = computeOrientationConfidence(
    orientation_residual,
    magnetic_field_directionality
);

// 综合置信度：加权平均
double confidence = 0.6 * position_confidence + 0.4 * orientation_confidence;
```

### 优点
- 更细粒度的不确定性评估
- 可以针对性地优化位置或姿态估计
- 控制策略可以根据不同置信度调整行为

### 缺点
- 计算复杂度增加
- 需要额外的传感器分布信息

---

## 方案3：基于协方差矩阵的置信度

### 设计思路
从优化器的Hessian矩阵或EKF的协方差矩阵直接计算置信度，反映估计的不确定性。

### 实现方式

#### 对于优化器（Ceres Solver）
```cpp
// 从Ceres的协方差矩阵计算
ceres::Covariance::Options cov_options;
ceres::Covariance covariance(cov_options);

std::vector<std::pair<const double*, const double*>> covariance_blocks;
// 添加位置和方向的协方差块
covariance_blocks.push_back({position, position});
covariance_blocks.push_back({direction, direction});

Eigen::MatrixXd cov_matrix;
covariance.Compute(covariance_blocks, &problem);
covariance.GetCovarianceBlock(position, position, cov_matrix.data());

// 计算置信度：基于协方差矩阵的行列式（不确定性体积）
double uncertainty_volume = std::sqrt(cov_matrix.determinant());
double confidence = 1.0 / (1.0 + uncertainty_volume * scale_factor);
```

#### 对于EKF
```cpp
// EKF已经有协方差矩阵P
Eigen::MatrixXd P = ekf_.getCovariance();
double position_uncertainty = std::sqrt(P.block<3,3>(0,0).determinant());
double orientation_uncertainty = std::sqrt(P.block<3,3>(3,3).determinant());

double confidence = 1.0 / (1.0 + position_uncertainty + orientation_uncertainty);
```

### 优点
- 理论基础扎实，基于概率论
- 直接反映估计的不确定性
- 可以计算置信区间

### 缺点
- 需要修改估计器接口，增加协方差计算
- 计算量较大（特别是优化器）

---

## 方案4：时间相关的置信度

### 设计思路
考虑时间因素：时间衰减、历史一致性、估计稳定性。

### 实现方式

```cpp
struct ConfidenceHistory {
    std::deque<double> confidence_history;  // 历史置信度
    std::deque<geometry_msgs::Pose> pose_history;  // 历史位姿
    ros::Time last_update_time;
    double time_decay_factor = 0.95;  // 时间衰减因子
};

double computeTimeAwareConfidence(
    double current_confidence,
    const ConfidenceHistory& history,
    const geometry_msgs::Pose& current_pose
) {
    // 1. 时间衰减
    double time_since_last = (ros::Time::now() - history.last_update_time).toSec();
    double time_decay = std::pow(time_decay_factor, time_since_last);
    
    // 2. 历史一致性：检查位姿变化是否平滑
    double pose_consistency = 1.0;
    if (!history.pose_history.empty()) {
        double pose_change = computePoseDistance(
            current_pose, 
            history.pose_history.back()
        );
        // 如果位姿变化过大，降低置信度
        if (pose_change > max_expected_change) {
            pose_consistency = 0.5;
        }
    }
    
    // 3. 稳定性：检查历史置信度的方差
    double stability = computeStability(history.confidence_history);
    
    // 综合置信度
    return current_confidence * time_decay * pose_consistency * stability;
}
```

### 优点
- 考虑时间因素，更符合实际应用
- 可以检测异常跳变
- 平滑的置信度变化

### 缺点
- 需要维护历史数据
- 内存和计算开销

---

## 方案5：基于传感器空间分布的置信度

### 设计思路
考虑传感器的空间分布对估计精度的影响。传感器分布越均匀、覆盖范围越大，置信度越高。

### 实现方式

```cpp
double computeSpatialDistributionConfidence(
    const std::vector<Eigen::Vector3d>& sensor_positions
) {
    if (sensor_positions.size() < 3) {
        return 0.0;
    }
    
    // 1. 计算传感器分布的中心
    Eigen::Vector3d center = Eigen::Vector3d::Zero();
    for (const auto& pos : sensor_positions) {
        center += pos;
    }
    center /= sensor_positions.size();
    
    // 2. 计算分布半径（传感器到中心的平均距离）
    double avg_radius = 0.0;
    for (const auto& pos : sensor_positions) {
        avg_radius += (pos - center).norm();
    }
    avg_radius /= sensor_positions.size();
    
    // 3. 计算分布均匀性（方差）
    double variance = 0.0;
    for (const auto& pos : sensor_positions) {
        double dist = (pos - center).norm();
        variance += (dist - avg_radius) * (dist - avg_radius);
    }
    variance /= sensor_positions.size();
    double uniformity = 1.0 / (1.0 + variance);  // 方差越小，均匀性越高
    
    // 4. 计算覆盖范围（传感器包围盒的体积）
    Eigen::Vector3d min_pos = sensor_positions[0];
    Eigen::Vector3d max_pos = sensor_positions[0];
    for (const auto& pos : sensor_positions) {
        min_pos = min_pos.cwiseMin(pos);
        max_pos = max_pos.cwiseMax(pos);
    }
    double coverage = (max_pos - min_pos).norm();
    
    // 综合置信度
    double confidence = 0.4 * uniformity + 0.6 * (coverage / max_expected_coverage);
    return std::min(1.0, confidence);
}
```

### 优点
- 考虑传感器布局的影响
- 可以指导传感器阵列的优化设计
- 更准确地反映估计精度

### 缺点
- 需要传感器位置信息
- 计算复杂度中等

---

## 方案6：自适应置信度阈值

### 设计思路
根据历史数据和当前场景动态调整置信度阈值，而不是使用固定阈值。

### 实现方式

```cpp
class AdaptiveConfidenceThreshold {
private:
    std::deque<double> recent_confidences;
    double baseline_threshold = 0.3;
    double adaptive_threshold;
    
public:
    double getThreshold() {
        if (recent_confidences.size() < 10) {
            return baseline_threshold;
        }
        
        // 计算最近N次的平均置信度
        double avg_confidence = 0.0;
        for (double conf : recent_confidences) {
            avg_confidence += conf;
        }
        avg_confidence /= recent_confidences.size();
        
        // 自适应阈值：基于历史平均值的百分比
        adaptive_threshold = avg_confidence * 0.7;  // 70%的历史平均值
        
        // 限制在合理范围内
        return std::max(0.2, std::min(0.8, adaptive_threshold));
    }
    
    void update(double confidence) {
        recent_confidences.push_back(confidence);
        if (recent_confidences.size() > 50) {
            recent_confidences.pop_front();
        }
    }
};
```

### 优点
- 适应不同场景和条件
- 减少误报和漏报
- 提高系统鲁棒性

### 缺点
- 需要一定的历史数据积累
- 可能延迟响应

---

## 方案7：置信度传播（不确定性传播）

### 设计思路
在控制系统中传播置信度，考虑控制动作对不确定性的影响。

### 实现方式

```cpp
// 在控制节点中
class ConfidenceAwareController {
    double propagateConfidence(
        double pose_confidence,
        double control_uncertainty,
        double execution_uncertainty
    ) {
        // 置信度传播：每一步都会引入不确定性
        // 使用乘法模型（独立性假设）
        double propagated_confidence = pose_confidence 
                                      * (1.0 - control_uncertainty)
                                      * (1.0 - execution_uncertainty);
        
        return std::max(0.0, propagated_confidence);
    }
    
    void controlLoop() {
        double current_confidence = current_magnet_confidence_;
        
        // 根据置信度调整控制参数
        if (current_confidence < 0.5) {
            // 低置信度：降低速度，增加安全距离
            config_.velocity_scaling *= 0.5;
            config_.max_movement_per_step *= 0.7;
        } else {
            // 高置信度：恢复正常参数
            config_.velocity_scaling = default_velocity_scaling;
            config_.max_movement_per_step = default_max_movement;
        }
        
        // 计算执行后的预期置信度
        double expected_confidence = propagateConfidence(
            current_confidence,
            0.1,  // 控制不确定性
            0.05  // 执行不确定性
        );
        
        if (expected_confidence < 0.3) {
            ROS_WARN("预期置信度过低，暂停控制");
            return;
        }
    }
};
```

### 优点
- 考虑整个系统的不确定性
- 可以预测和预防问题
- 更智能的控制决策

### 缺点
- 需要建模各环节的不确定性
- 实现复杂度较高

---

## 方案8：基于Fisher信息矩阵的置信度

### 设计思路
使用Fisher信息矩阵（FIM）评估估计的可观测性，可观测性越高，置信度越高。

### 实现方式

```cpp
// Fisher信息矩阵 = J^T * W * J
// 其中J是雅可比矩阵，W是权重矩阵（通常是测量噪声的逆）
Eigen::MatrixXd computeFisherInformationMatrix(
    const std::vector<Eigen::Vector3d>& sensor_positions,
    const Eigen::Vector3d& magnet_position,
    const Eigen::Vector3d& magnet_direction
) {
    Eigen::MatrixXd FIM = Eigen::MatrixXd::Zero(6, 6);  // 6个参数：位置(3) + 方向(3)
    
    for (const auto& sensor_pos : sensor_positions) {
        // 计算雅可比矩阵J
        Eigen::Matrix<double, 3, 6> J = computeJacobian(
            sensor_pos, magnet_position, magnet_direction
        );
        
        // 权重矩阵（测量噪声的逆）
        double noise_variance = 1.0e-3;  // 1 mT^2
        Eigen::Matrix3d W = Eigen::Matrix3d::Identity() / noise_variance;
        
        // 累加Fisher信息
        FIM += J.transpose() * W * J;
    }
    
    return FIM;
}

double computeConfidenceFromFIM(const Eigen::MatrixXd& FIM) {
    // 计算FIM的行列式（信息量）
    double information_volume = std::sqrt(FIM.determinant());
    
    // 计算FIM的条件数（可观测性指标）
    Eigen::JacobiSVD<Eigen::MatrixXd> svd(FIM);
    double condition_number = svd.singularValues()(0) / 
                              svd.singularValues()(svd.singularValues().size()-1);
    
    // 置信度：信息量越大，条件数越小（越接近1），置信度越高
    double confidence = std::min(1.0, information_volume / max_expected_info);
    confidence *= (1.0 / condition_number);  // 条件数惩罚
    
    return std::max(0.0, std::min(1.0, confidence));
}
```

### 优点
- 理论基础扎实（信息论）
- 可以评估可观测性
- 可以指导传感器布局优化

### 缺点
- 计算复杂度高
- 需要雅可比矩阵

---

## 推荐组合方案

### 方案A：简单高效（当前实现 + 时间衰减）
```cpp
confidence = base_confidence * time_decay_factor
```
- 适合：实时性要求高的场景
- 实现简单，效果明显

### 方案B：中等复杂度（多维度 + 空间分布）
```cpp
confidence = f(position_conf, orientation_conf, spatial_distribution)
```
- 适合：需要细粒度控制的场景
- 平衡了准确性和计算复杂度

### 方案C：高精度（协方差矩阵 + Fisher信息）
```cpp
confidence = f(covariance_matrix, fisher_information_matrix)
```
- 适合：科研或高精度应用
- 理论基础扎实，但计算量大

---

## 实现建议

1. **渐进式实现**：先实现简单方案，再逐步添加复杂特性
2. **可配置**：通过配置文件选择置信度计算方案
3. **性能监控**：记录置信度计算时间，确保不影响实时性
4. **可视化**：在RViz中显示置信度（颜色、透明度等）

---

## 总结

不同方案适用于不同场景：
- **实时控制**：方案1（当前）或方案A
- **高精度应用**：方案3（协方差）或方案8（Fisher信息）
- **长期运行**：方案4（时间相关）或方案6（自适应）
- **传感器优化**：方案5（空间分布）或方案8（Fisher信息）

可以根据具体需求选择合适的方案或组合使用。

